!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.VueSvgInlinePlugin=t():e.VueSvgInlinePlugin=t()}(window,(function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="/",r(r.s=1)}([function(e){e.exports=JSON.parse('{"a":"vue-svg-inline-plugin","b":"1.2.0"}')},function(e,t,r){"use strict";r.r(t);var n=r(0);
/**
 * @author Oliver Findl
 * @version 1.2.0
 * @license MIT
 */
const i=n.a;const o={directives:{inline:"v-svg-inline",inlineSprite:"v-svg-inline-sprite"},attributes:{merge:["class","style"],add:[{name:"focusable",value:!1},{name:"role",value:"presentation"},{name:"tabindex",value:-1}],data:[],remove:["alt","src","data-src"]},cache:{version:n.b,persistent:!0,removeRevisions:!0},intersectionObserverOptions:{},axios:null,xhtml:!1},s=`${i}-flags`,a=`${i}-sprite`,c=`${a}-container`,l=/.+\.svg(?:[?#].*)?$/i,u=/<svg(\s+[^>]+)?>([\s\S]+)<\/svg>/i,d=/\s*([^\s=]+)[\s=]+(?:"([^"]*)"|'([^']*)')?\s*/g,p=/^[a-z](?:[a-z0-9-:]*[a-z0-9])?$/i,f=/^v-/i,g=/\s+/g,h=/[\n\t]+/g,w=new Set([200,304]);t.default={install:(e=null,t={})=>{["directives","attributes","cache","intersectionObserverOptions"].forEach(e=>t[e]=Object.assign({},o[e],t[e]||{})),t=Object.assign({},o,t);for(const e in t.directives){if(t.directives[e]=t.directives[e].toString().trim().toLowerCase(),!p.test(t.directives[e]))throw new TypeError(`[${i}] Option is not valid! [options.directives.${e}="${t.directives[e]}"]`);t.directives[e]=t.directives[e].replace(f,"")}for(const e in t.attributes){if(!Array.isArray(t.attributes[e]))throw new TypeError(`[${i}] Option is not valid! [options.attributes.${e}=${JSON.stringify(t.attributes[e])}]`);t.attributes[e]="add"===e?t.attributes[e].map(e=>({name:e.name.toString().trim().toLowerCase(),value:e.value.toString().trim()})):t.attributes[e].map(e=>e.toString().trim().toLowerCase()),t.attributes[e]=new Set(t.attributes[e])}for(const e in t.cache)t.cache[e]="version"===e?t.cache[e].toString().trim().toLowerCase():!!t.cache[e];t.xhtml=!!t.xhtml;const r="function";t._fetch="fetch"in window&&typeof fetch===r,t._axios="axios"in window&&typeof axios===r;const n=(e=null)=>!!e&&typeof e===r&&"get"in e&&typeof e.get===r;let m=!1;if(t.axios=((m=n(t.axios))?t.axios:null)||(t._axios&&"create"in axios&&typeof axios.create===r?axios.create():null),t._axios=m||n(t.axios),!t._fetch&&!t._axios)throw new Error(`[${i}] Feature is not supported by browser! [fetch || axios]`);t._observer="IntersectionObserver"in window,t._observer||console.error(`[${i}] Feature is not supported by browser! Disabling lazy processing of image nodes. [IntersectionObserver]`),t._storage="localStorage"in window,!t._storage&&t.cache.persistent&&console.error(`[${i}] Feature is not supported by browser! Disabling persistent cache of SVG files. [localStorage]`);const v=`${i}:${t.cache.version}`;t._storage&&t.cache.removeRevisions&&Object.entries(localStorage).map(e=>e.shift()).filter(e=>e.startsWith(`${i}:`)&&!e.endsWith(`:${t.cache.version}`)).forEach(e=>localStorage.removeItem(e));const b=t._storage&&t.cache.persistent?new Map(JSON.parse(localStorage.getItem(v)||"[]")):new Map,$=new Set,y=new Map,x=()=>y.has("observer")?y.get("observer"):(()=>{if(!t._observer)throw new Error(`[${i}] Feature is not supported by browser! [IntersectionObserver]`);if(y.has("observer"))throw new Error(`[${i}] Can not create image node intersection observer, intersection observer already exists!`);const e=new IntersectionObserver((e,t)=>{for(const r of e){if(!r.isIntersecting)continue;const e=r.target;M(e),t.unobserve(e)}},t.intersectionObserverOptions);return y.set("observer",e),e})(),S=()=>y.has("container")?y.get("container"):(()=>{if(y.has("container"))throw new Error(`[${i}] Can not create SVG symbol container node, container node already exists!`);let e=E(`<svg xmlns="http://www.w3.org/2000/svg" id="${c}" style="display: none !important;"></svg>`);return document.body.appendChild(e),y.set("container",e=document.getElementById(c)),e})(),E=(e="")=>{if(!e)throw new Error(`[${i}] Missing required argument! [string]`);if(!(e=e.toString().trim()).startsWith("<")||!e.endsWith(">"))throw new TypeError(`[${i}] Argument is not valid! [string="${e}"]`);return e=e.replace(h,""),document.createRange().createContextualFragment(e)},O=(e="")=>{if(!e)throw new Error(`[${i}] Missing required argument! [string]`);e=e.toString().trim();const r=new Map;let n;for(d.lastIndex=0;n=d.exec(e);){n.index===d.lastIndex&&d.lastIndex++;const e=(n[1]||"").trim().toLowerCase();if(!e||e.startsWith("<")||e.endsWith(">"))continue;if(!p.test(e))throw new TypeError(`[${i}] Attribute name is not valid! [attribute="${e}"]`);const o=(n[2]||n[3]||"").trim();r.set(e,o||(t.xhtml?e:""))}return r},M=(e=null)=>{if(!e)throw new Error(`[${i}] Missing required argument! [node]`);if(!e.dataset.src&&!e.src)throw new Error(`[${i}] Missing required argument property! [node.data-src || node.src]`);e.dataset.src&&(e.dataset.src=e.dataset.src.toString().trim()),e.src&&(e.src=e.src.toString().trim()),((e="")=>{if(!t._fetch&&!t._axios)throw new Error(`[${i}] Feature is not supported by browser! [fetch || axios]`);if(!e)throw new Error(`[${i}] Missing required argument! [path]`);if(e=e.toString().trim(),!l.test(e))throw new TypeError(`[${i}] Argument is not valid! [path="${e}"]`);return new Promise((r,n)=>{const i={path:e};if(b.has(i.path))return i.content=b.get(i.path),r(i);(t._axios?t.axios.get:fetch)(i.path).then(e=>{if(!w.has(0|e.status))throw new Error(`Wrong response status! [response.status=${e.status}]`);return t._axios?e.data.toString():e.text()}).then(e=>(i.content=e.trim(),b.set(i.path,i.content),t._storage&&t.cache.persistent&&localStorage.setItem(v,JSON.stringify([...b])),r(i))).catch(n)})})(e.dataset.src||e.src).then(r=>{const n=((e=null,r=null)=>{if(!e)throw new Error(`[${i}] Missing required argument! [file]`);if(!r)throw new Error(`[${i}] Missing required argument! [node]`);if(!e.path)throw new Error(`[${i}] Missing required argument property! [file.path]`);if(e.path=e.path.toString().trim(),!l.test(e.path))throw new TypeError(`[${i}] Argument property is not valid! [file.path="${e.path}"]`);if(!e.content)throw new Error(`[${i}] Missing required argument property! [file.content]`);if(e.content=e.content.toString().trim(),!u.test(e.content))throw new TypeError(`[${i}] Argument property is not valid! [file.content="${e.content}"]`);if(!r.outerHTML)throw new Error(`[${i}] Missing required argument property! [node.outerHTML]`);return r[s].has("sprite")&&(e.content=e.content.replace(u,(t,r,n)=>{const i=$.has(e.path),o=`${a}-${i?[...$].indexOf(e.path):$.size}`;if(!i){const t=E(`<svg xmlns="http://www.w3.org/2000/svg"><symbol id="${o}"${r}>${n}</symbol></svg>`);S().appendChild(t.firstChild.firstChild),$.add(e.path)}return`<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><use xlink:href="#${o}" href="#${o}"></use></svg>`})),e.content.replace(u,(e,n,o)=>{const s=r.outerHTML.toString().trim(),a=O(n),c=O(s);n=new Map([...a,...c]);const l=new Set(["class"]);for(const e of t.attributes.merge){const r=a.has(e)?a.get(e).split(g).filter(e=>!!e):[],i=c.has(e)?c.get(e).split(g).filter(e=>!!e):[];if(t.xhtml&&!r.length&&!i.length)continue;const o=[...r,...i];n.set(e,(l.has(e)?[...new Set(o)]:o).join(" ").trim())}for(const e of t.attributes.add){let r=e.value.split(g).filter(e=>!!e);if(n.has(e.name)){if(!t.attributes.merge.has(e.name))throw new Error(`[${i}] Can not add attribute, attribute already exists. [${e.name}]`);const o=n.get(e.name).split(g).filter(e=>!!e);if(t.xhtml&&!r.length&&!o.length)continue;r=[...o,...r]}n.set(e.name,(l.has(e.name)?[...new Set(r)]:r).join(" ").trim())}for(const e of t.attributes.data){if(!n.has(e))continue;let r=n.get(e).split(g).filter(e=>!!e);const o=`data-${e}`;if(n.has(o)){if(!t.attributes.merge.has(o))throw new Error(`[${i}] Can not transform attribute to data-attribute, data-attribute already exists. [${e}]`);const s=n.get(o).split(g).filter(e=>!!e);if(t.xhtml&&!r.length&&!s.length)continue;r=[...s,...r]}n.set(o,(l.has(e)?[...new Set(r)]:r).join(" ").trim()),t.attributes.remove.has(e)||t.attributes.remove.add(e)}for(const e of t.attributes.remove)n.has(e)&&n.delete(e);return`<svg${n.size?` ${[...n.keys()].filter(e=>!!e).map(e=>`${e}="${n.get(e)}"`).join(" ")}`:""}>${o}</svg>`})})(r,e),o=E(n);((e=null,t=null)=>{if(!e)throw new Error(`[${i}] Missing required argument! [node]`);if(!t)throw new Error(`[${i}] Missing required argument! [newNode]`);if(!e.parentNode)throw new Error(`[${i}] Missing required argument property! [node.parentNode]`);e.parentNode.replaceChild(t,e)})(e,o)}).catch(e=>console.error(`[${i}] ${e.toString()}`))},_=(e=null,r=null,n=null)=>{if(!e)throw new Error(`[${i}] Missing required argument! [node]`);if(!n)throw new Error(`[${i}] Missing required argument! [vnode]`);if(e[s]||(e[s]=new Set),!e[s].has("processed")){if(e[s].add("processed"),n.data.directives.length>1)throw new Error(`[${i}] Node has more than 1 directive! [vnode.data.directives=${JSON.stringify(n.data.directives.map(e=>e.name))}]`);n.data.directives.pop().name===t.directives.inlineSprite&&e[s].add("sprite"),!t._observer&&e.dataset.src&&(e.src=e.dataset.src,delete e.dataset.src),e.dataset.src?x().observe(e):M(e)}};e.directive(t.directives.inline,{bind:_}),e.directive(t.directives.inlineSprite,{bind:_})}}}]).default}));